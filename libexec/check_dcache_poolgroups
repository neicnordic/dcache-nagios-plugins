#! /usr/bin/env python
#
# Nagios probe to check dCache pool groups and submit results to passive
# services.  Checks performed include heartbeats of member pools, free space,
# and non-precious space.

import argparse, os, sys, time, traceback
from ndgfnagios import tconf
from ndgfnagios.utils import size_float, show_size, FreeObject
from ndgfnagios.utils import counted_noun, plcase
from ndgfnagios.dcacheinfo import load_poolgroups, load_pools, \
				  load_domain_poolnames

def check_poolgroup(g, args, nagcmd_fh):
    service_count = 0
    rs = {}

    def statusobject():
	return FreeObject(retcode = 0, okmsgs = [], msgs = [])

    if args.heartbeat_enabled:
	if not args.heartbeat_service in rs:
	    rs[args.heartbeat_service] = statusobject()
	rs[args.heartbeat_service].okmsgs.append(
		'Group of ' + counted_noun(len(g.poolrefs), 'pool'))
    if args.available_enabled:
	r = rs[args.available_service] = statusobject()
	if g.total_space:
	    r.okmsgs.append('%s (%.2g) available' %
		(show_size(g.available_space), g.available_space / float(g.total_space)))
    if args.free_enabled:
	r = rs[args.free_service] = statusobject()
	if g.total_space:
	    r.okmsgs.append('%s (%.2g) free' %
		(show_size(g.free_space), g.free_space / float(g.total_space)))
    if args.nonprecious_enabled:
	if not args.nonprecious_service in rs:
	    rs[args.nonprecious_service] = statusobject()
	r = rs[args.nonprecious_service]
	if g.total_space and g.precious_space:
	    r.okmsgs.append('%s (%.2g) nonprecious' %
		(show_size(g.nonprecious_space), g.nonprecious_space / float(g.total_space)))

    # Check for high heartbeat if requested.
    if args.heartbeat_enabled:
	hc_count = hw_count = ro_count = 0
	hc_pools = []
	hw_pools = []
	ro_pools = []
	for pn in g.poolrefs:
	    p = ps[pn]
	    if p.read_only:
		ro_count += 1
		ro_pools.append(p.name)
	    if args.heartbeat_limit[0] \
		    and p.last_heartbeat > args.heartbeat_limit[0]:
		hc_count += 1
		hc_pools.append(p.name)
	    elif args.heartbeat_limit[1] \
		    and p.last_heartbeat > args.heartbeat_limit[1]:
		hw_count += 1
		hw_pools.append(p.name)
	r = rs[args.heartbeat_service]
	def report_pools(count, pools, retcode, msg_s, msg_pl):
	    if count > 0:
		r.retcode = retcode
		msg = plcase(count, msg_s, msg_pl)
		if args.list_pools:
		    r.msgs.append('%s: %s.'%(msg, ', '.join(pools)))
		else:
		    r.msgs.append(msg + '.')
	report_pools(hc_count, hc_pools, 2,
		'%(count)d pool has critical heartbeat',
		'%(count)d pools have critical heartbeat')
	report_pools(hw_count, hw_pools, 1,
		'%(count)d pool has high heartbeat',
		'%(count)d pools have critical heartbeat')
	if ro_count == len(g.poolrefs):
	    r.retcode = 2
	    r.msgs.append('All pools are read-only.')
	else:
	    report_pools(ro_count, ro_pools, 1,
		'%(count)d pool is read-only',
		'%(count)d pools are read-only')

    # Check utilization.
    def check_space(r, rlimit, alimit, free_space, retcode, msg):
	c0 = c1 = args.conjunct
	if not rlimit is None:
	    c0 = free_space < rlimit*g.total_space
	if not alimit is None:
	    c1 = free_space < alimit
	if c0 and c1 or (not args.conjunct and (c0 or c1)):
	    r.retcode = max(r.retcode, retcode)
	    r.msgs.append(msg)
	    return True
	return False
    if g.total_space > 0:
	if args.available_enabled:
	    check_space(rs[args.available_service],
			args.available_rlimit[0], args.available_alimit[0],
			g.available_space,
			2, 'Available space is critical.') or \
	    check_space(rs[args.available_service],
			args.available_rlimit[1], args.available_alimit[1],
			g.available_space,
			1, 'Available space is low.')
	if args.free_enabled:
	    check_space(rs[args.free_service],
			args.free_rlimit[0], args.free_alimit[0], g.free_space,
			2, 'Free space is critical.') or \
	    check_space(rs[args.free_service],
			args.free_rlimit[1], args.free_alimit[1], g.free_space,
			1, 'Free space is low.')
	if args.nonprecious_enabled:
	    check_space(rs[args.nonprecious_service],
			args.nonprecious_rlimit[0], args.nonprecious_alimit[0],
			g.nonprecious_space,
			2, 'Non-precious space is critical.') or \
	    check_space(rs[args.nonprecious_service],
			args.nonprecious_rlimit[1], args.nonprecious_alimit[1],
			g.nonprecious_space,
			1, 'Non-precious space is low.')
    else:
	if args.free_enabled or args.nonprecious_enabled:
	    for s in set([args.free_service, args.nonprecious_service]):
		rs[s].retcode = 0
		rs[s].msgs.append('No space allocated.')

    # Submit passive result.
    t = int(time.time())
    for ssfx, r in rs.iteritems():
	msg = ''
	if r.okmsgs:
	    msg = ', '.join(r.okmsgs) + '. '
	if r.msgs:
	    msg += ' '.join(r.msgs)
	nagcmd_fh.write(
		'[%d] PROCESS_SERVICE_CHECK_RESULT;%s;%s;%d;%s\n' \
		% (t, args.host, args.service_prefix + g.name + ssfx, r.retcode,
		   msg.strip() or 'Poolgroup is ok.'))
	service_count += 1
    return service_count

def cwpair(t):
    def f(s):
	if ',' in s:
	    s0, s1 = s.split(',', 1)
	    return s0 and t(s0), s1 and t(s1)
	else:
	    return t(s), None
    return f

def cslist(t):
    def f(s):
	return map(t, s.split(','))
    return f
try:
    ap = argparse.ArgumentParser()
    ap.add_argument('-H', dest = 'host', required = True,
	    help = 'Target host for passive results.')
    ap.add_argument('-U', dest = 'url',
	    help = 'The info URL under which to make queries.')
    ap.add_argument('-a', dest = 'all', action = 'store_true', default = False,
	    help = 'Check all poolgroups.')

    ap.add_argument('-A', dest = 'conjunct',
	    action = 'store_true', default = False,
	    help = 'If absolute and relative limits are given, trigger only '
		   'if both fail.  By default, trigger when either fail.')

    ap.add_argument('--exclude', nargs = '+', default = [],
	    help = 'Exclude specified poolgroups.')
    ap.add_argument('--service-prefix', default = '',
	    help = 'Prefix all passive services with this string.')

    ap.add_argument('--available-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low available space')
    ap.add_argument('--available-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. advisable available space')
    ap.add_argument('--available-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. advisable available space relative to the total')

    ap.add_argument('--free-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low free space')
    ap.add_argument('--free-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. advisable free space')
    ap.add_argument('--free-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. advisable free space relative to the total')

    ap.add_argument('--nonprecious-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low non-precious '
		   'space.')
    ap.add_argument('--nonprecious-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. available non-specious space.')
    ap.add_argument('--nonprecious-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. available non-specious space relative to total.')

    ap.add_argument('--heartbeat-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting heartbeat.')
    ap.add_argument('--heartbeat-limit', dest = 'heartbeat_limit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_TIME',
	    help = 'critical[,warning]: Max advisable heartbeat.')
    ap.add_argument('--list-pools', action = 'store_true', default = False,
	    help = 'List pools with critical or high heartbeat.')

    ap.add_argument('--check-pools-tconf', metavar = 'PATH',
	    help = 'Check if PATH lists all the pools in monitored poolgroups.')

    args = ap.parse_args()
    args.available_enabled = any(args.available_alimit) \
			  or any(args.available_rlimit)
    args.free_enabled = any(args.free_alimit) or any(args.free_rlimit)
    args.nonprecious_enabled = any(args.nonprecious_alimit) \
			    or any(args.nonprecious_rlimit)
    args.heartbeat_enabled = any(args.heartbeat_limit)
    if args.url is None:
	args.url = 'http://%s:2288/info'%args.host

    # Open stream for submitting passive result.
    nagcmd_path = os.getenv('NAGIOS_COMMANDFILE')
    if nagcmd_path:
	nagcmd_fh = open(nagcmd_path, 'w')
    else:
	nagcmd_fh = sys.stdout

    # Check pool groups.
    gs = load_poolgroups(args.url + '/poolgroups')
    if args.heartbeat_limit[0] or args.heartbeat_limit[1] \
	    or args.check_pools_tconf:
	ps = dict((p.name, p) for p in load_pools(args.url + '/pools'))
    service_count = 0
    gcount = 0
    for g in gs:
	if not g.name in args.exclude:
	    service_count += check_poolgroup(g, args, nagcmd_fh)
	    gcount += 1

    if nagcmd_path:
	nagcmd_fh.close()

    # Check pools missing from pools.tconf if requested.
    missing = []
    partially_monitored = {}
    if args.check_pools_tconf:
	visitor = tconf.TconfAccumulatingVisitor()
	tconf = tconf.load_tconf(args.check_pools_tconf, visitor)
	calls = visitor.calls.get('pool', []) + visitor.calls.get('poolh', [])
	tpools = set([poolname for (hostname, poolname), _ in calls])

	# Pools which are member of pool groups.
	for p in ps.itervalues():
	    for gn in p.poolgrouprefs:
		if not gn in args.exclude:
		    if not p.name in tpools:
			missing.append((p.name, gn))
		    break

	# Pools on domains where at least one pool is monitored.
	for dn, pns in load_domain_poolnames(args.url):
	    is_monitored = False
	    for pn in pns:
		if pn in tpools:
		    is_monitored = True
	    if is_monitored:
		unmon_pns = [p for p in pns if not p in tpools]
		if unmon_pns:
		    partially_monitored[dn] = unmon_pns

    if not missing and not partially_monitored:
	status_code = 0
	print 'Reported %d poolgroups to %d services.'%(gcount, service_count)
    else:
	status_code = 1
	npm = sum(len(pns) for pns in partially_monitored.itervalues())
	print 'Reported %d poolgroups to %d services, ' \
	      'found %d + %d unmonitored pools.' \
	    % (gcount, service_count, len(missing), npm)
    if missing:
	print 'Pools missing from %s:'%args.check_pools_tconf
	for pn, gn in missing:
	    print '  - %s in group %s'%(pn, gn)
    if partially_monitored:
	print 'Unmonitored pools in monitored domains:'
	dns = partially_monitored.keys()
	dns.sort()
	for dn in dns:
	    pns = list(partially_monitored[dn])
	    pns.sort()
	    print '  - In %s: %s'%(dn, ', '.join(pns))
    sys.exit(status_code)
except Exception, xc:
    print 'Exception: %s'%xc
    _0, _1, tb = sys.exc_info()
    for ln in traceback.format_tb(tb):
	print ln,
    sys.exit(3)

#! /usr/bin/env python
#
# Nagios probe to check dCache pool groups and submit results to passive
# services.  Checks performed include heartbeats of member pools, free space,
# and non-precious space.

import argparse, os, sys, time, traceback
from ndgfnagios import tconf
from ndgfnagios.utils import size_float, show_size, FreeObject
from ndgfnagios.utils import counted_noun, plcase
from ndgfnagios.dcacheinfo import load_poolgroups, load_pools, \
				  load_domain_poolnames

class PassiveChecker(object):

    _ok_message = 'Service is ok.'

    def __init__(self, host, nagcmd_fh = sys.stdout):
	self._host = host
	self._results = {}
	self._nagcmd_fh = nagcmd_fh

    def status_for_service(self, service):
	if not service in self._results:
	    self._results[service] = FreeObject(retcode = 0, okmsgs = [], msgs = [])
	return self._results[service]

    def report_passive(self):
	t = int(time.time())
	service_count = 0
	for svc_name, r in self._results.iteritems():
	    msg = ''
	    if r.okmsgs:
		msg = ', '.join(r.okmsgs) + '. '
	    if r.msgs:
		msg += ' '.join(r.msgs)
	    self._nagcmd_fh.write(
		    '[%d] PROCESS_SERVICE_CHECK_RESULT;%s;%s;%d;%s\n' \
		    % (t, self._host, svc_name, r.retcode,
		       msg.strip() or self._ok_message))
	    service_count += 1
	return service_count

class PoolsetChecker(PassiveChecker):

    _ok_message = 'Pools are ok.'
    _svc_template = '%(poolset)s %(metric)s'

    def __init__(self, args, nagcmd_fh = sys.stdout):
	PassiveChecker.__init__(self, args.host, nagcmd_fh = nagcmd_fh)
	self._args = args

    def status_for(self, poolset_name, metric):
	d = dict(poolset = poolset_name, metric = metric)
	service_name = (self._svc_template % d).strip()
	return self.status_for_service(service_name)

    def check_pools(self, poolrefs, poolset_name):
	r = self.status_for(poolset_name, self._args.heartbeat_service)
	r.okmsgs.append('Group of ' + counted_noun(len(poolrefs), 'pool'))

	hc_count = hw_count = ro_count = 0
	hc_pools = []
	hw_pools = []
	ro_pools = []
	for pn in poolrefs:
	    p = ps[pn]
	    if p.read_only:
		ro_count += 1
		ro_pools.append(p.name)
	    if self._args.heartbeat_limit[0] \
		    and p.last_heartbeat > self._args.heartbeat_limit[0]:
		hc_count += 1
		hc_pools.append(p.name)
	    elif self._args.heartbeat_limit[1] \
		    and p.last_heartbeat > self._args.heartbeat_limit[1]:
		hw_count += 1
		hw_pools.append(p.name)
	def report_pools(count, pools, retcode, msg_s, msg_pl):
	    if count > 0:
		r.retcode = retcode
		msg = plcase(count, msg_s, msg_pl)
		if self._args.list_pools:
		    r.msgs.append('%s: %s.'%(msg, ', '.join(pools)))
		else:
		    r.msgs.append(msg + '.')
	report_pools(hc_count, hc_pools, 2,
		'%(count)d pool has critical heartbeat',
		'%(count)d pools have critical heartbeat')
	report_pools(hw_count, hw_pools, 1,
		'%(count)d pool has high heartbeat',
		'%(count)d pools have critical heartbeat')
	if ro_count == len(poolrefs):
	    r.retcode = 2
	    r.msgs.append('All pools are read-only.')
	else:
	    report_pools(ro_count, ro_pools, 1,
		'%(count)d pool is read-only',
		'%(count)d pools are read-only')

class PoolgroupChecker(PoolsetChecker):

    _ok_message = 'Poolgroup is ok.'

    def __init__(self, args, nagcmd_fh = sys.stdout):
	self._args = args
	PassiveChecker.__init__(self, args.host, nagcmd_fh = nagcmd_fh)
	self._svc_template = args.poolgroup_prefix + self._svc_template

    def check_poolgroup(self, g):
	if self._args.available_enabled:
	    r = self.status_for(g.name, self._args.available_service)
	    if g.total_space:
		r.okmsgs.append('%s (%.2g) available' %
		    (show_size(g.available_space),
		     g.available_space / float(g.total_space)))
	if self._args.free_enabled:
	    r = self.status_for(g.name, self._args.free_service)
	    if g.total_space:
		r.okmsgs.append('%s (%.2g) free' %
		    (show_size(g.free_space),
		     g.free_space / float(g.total_space)))
	if self._args.nonprecious_enabled:
	    r = self.status_for(g.name, self._args.nonprecious_service)
	    if g.total_space and g.precious_space:
		r.okmsgs.append('%s (%.2g) nonprecious' %
		    (show_size(g.nonprecious_space),
		     g.nonprecious_space / float(g.total_space)))

	# Check utilization.
	def ckspace(r, rlimit, alimit, free_space, retcode, msg):
	    c0 = c1 = self._args.conjunct
	    if not rlimit is None:
		c0 = free_space < rlimit*g.total_space
	    if not alimit is None:
		c1 = free_space < alimit
	    if c0 and c1 or (not self._args.conjunct and (c0 or c1)):
		r.retcode = max(r.retcode, retcode)
		r.msgs.append(msg)
		return True
	    return False
	def ckspace2(r, rlimits, alimits, free_space, what):
	    msg0 = what.capitalize() + ' space is critically low.'
	    msg1 = what.capitalize() + ' space is low.'
	    ckspace(r, rlimits[0], alimits[0], free_space, 2, msg0) or \
	    ckspace(r, rlimits[1], alimits[1], free_space, 1, msg1)
	if g.total_space > 0:
	    if self._args.available_enabled:
		r = self.status_for(g.name, self._args.available_service)
		ckspace2(r, self._args.available_rlimit, self._args.available_alimit,
			 g.available_space, 'available')
	    if self._args.free_enabled:
		r = self.status_for(g.name, self._args.free_service)
		ckspace2(r, self._args.free_rlimit, self._args.free_alimit,
			 g.free_space, 'free')
	    if self._args.nonprecious_enabled:
		r = self.status_for(g.name, self._args.nonprecious_service)
		ckspace2(r, self._args.nonprecious_rlimit, self._args.nonprecious_alimit,
			 g.nonprecious_space, 2, 'non-precious')
	else:
	    if self._args.free_enabled or self._args.nonprecious_enabled:
		for s in set([self._args.free_service, self._args.nonprecious_service]):
		    r = self.status_for(g.name, s)
		    r.retcode = 0
		    r.msgs.append('No space allocated.')

def cwpair(t):
    def f(s):
	if ',' in s:
	    s0, s1 = s.split(',', 1)
	    return s0 and t(s0), s1 and t(s1)
	else:
	    return t(s), None
    return f

def cslist(t):
    def f(s):
	return map(t, s.split(','))
    return f
try:
    ap = argparse.ArgumentParser()
    ap.add_argument('-H', dest = 'host', required = True,
	    help = 'Target host for passive results.')
    ap.add_argument('-U', dest = 'url',
	    help = 'The info URL under which to make queries.')
    ap.add_argument('-a', dest = 'all', action = 'store_true', default = False,
	    help = 'Check all poolgroups.')

    ap.add_argument('-A', dest = 'conjunct',
	    action = 'store_true', default = False,
	    help = 'If absolute and relative limits are given, trigger only '
		   'if both fail.  By default, trigger when either fail.')

    ap.add_argument('--exclude', nargs = '+', default = [],
	    help = 'Exclude specified poolgroups.')
    ap.add_argument('--poolgroup-prefix', default = 'PG ',
	    help = 'Prefix passive services for poolgroups with this string.')

    ap.add_argument('--available-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low available space')
    ap.add_argument('--available-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. advisable available space')
    ap.add_argument('--available-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. advisable available space relative to the total')

    ap.add_argument('--free-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low free space')
    ap.add_argument('--free-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. advisable free space')
    ap.add_argument('--free-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. advisable free space relative to the total')

    ap.add_argument('--nonprecious-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting low non-precious '
		   'space.')
    ap.add_argument('--nonprecious-alimit',
	    type = cwpair(size_float), default = (None, None),
	    metavar = 'CW_SIZE',
	    help = 'Min. available non-specious space.')
    ap.add_argument('--nonprecious-rlimit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_RATIO',
	    help = 'Min. available non-specious space relative to total.')

    ap.add_argument('--heartbeat-service', default = '',
	    metavar = 'SERVICE_SUFFIX',
	    help = 'Target service suffix for reporting heartbeat.')
    ap.add_argument('--heartbeat-limit', dest = 'heartbeat_limit',
	    type = cwpair(float), default = (None, None),
	    metavar = 'CW_TIME',
	    help = 'critical[,warning]: Max advisable heartbeat.')
    ap.add_argument('--list-pools', action = 'store_true', default = False,
	    help = 'List pools with critical or high heartbeat.')

    ap.add_argument('--check-pools-tconf', metavar = 'PATH',
	    help = 'Check if PATH lists all the pools in monitored poolgroups.')

    args = ap.parse_args()
    args.available_enabled = any(args.available_alimit) \
			  or any(args.available_rlimit)
    args.free_enabled = any(args.free_alimit) or any(args.free_rlimit)
    args.nonprecious_enabled = any(args.nonprecious_alimit) \
			    or any(args.nonprecious_rlimit)
    args.heartbeat_enabled = any(args.heartbeat_limit)
    if args.url is None:
	args.url = 'http://%s:2288/info'%args.host

    # Open stream for submitting passive result.
    nagcmd_path = os.getenv('NAGIOS_COMMANDFILE')
    if nagcmd_path:
	nagcmd_fh = open(nagcmd_path, 'w')
    else:
	nagcmd_fh = sys.stdout

    # Check pool groups.
    gs = load_poolgroups(args.url + '/poolgroups')
    if args.heartbeat_limit[0] or args.heartbeat_limit[1] \
	    or args.check_pools_tconf:
	ps = dict((p.name, p) for p in load_pools(args.url + '/pools'))
    service_count = 0
    gcount = 0
    for g in gs:
	if not g.name in args.exclude:
	    checker = PoolgroupChecker(args = args, nagcmd_fh = nagcmd_fh)
	    if args.heartbeat_enabled:
		checker.check_pools(g.poolrefs, g.name)
	    checker.check_poolgroup(g)
	    service_count += checker.report_passive()
	    gcount += 1

    if nagcmd_path:
	nagcmd_fh.close()

    # Check pools missing from pools.tconf if requested.
    missing = []
    partially_monitored = {}
    if args.check_pools_tconf:
	visitor = tconf.TconfAccumulatingVisitor()
	tconf = tconf.load_tconf(args.check_pools_tconf, visitor)
	calls = visitor.calls.get('pool', []) + visitor.calls.get('poolh', [])
	tpools = set([poolname for (hostname, poolname), _ in calls])

	# Pools which are member of pool groups.
	for p in ps.itervalues():
	    for gn in p.poolgrouprefs:
		if not gn in args.exclude:
		    if not p.name in tpools:
			missing.append((p.name, gn))
		    break

	# Pools on domains where at least one pool is monitored.
	for dn, pns in load_domain_poolnames(args.url):
	    is_monitored = False
	    for pn in pns:
		if pn in tpools:
		    is_monitored = True
	    if is_monitored:
		unmon_pns = [p for p in pns if not p in tpools]
		if unmon_pns:
		    partially_monitored[dn] = unmon_pns

    if not missing:
	status_code = 0
	if not partially_monitored:
	    print 'Reported %d poolgroups to %d services.'%(gcount, service_count)
	else:
	    print 'Reported %d poolgorups to %d services, ' \
		  '%d domain is partially monitored.' \
		  % (gcount, service_count, len(partially_monitored))
    else:
	status_code = 1
	npm = sum(len(pns) for pns in partially_monitored.itervalues())
	print 'Reported %d poolgroups to %d services, ' \
	      'found %d + %d unmonitored pools.' \
	    % (gcount, service_count, len(missing), npm)
    if missing:
	print 'Pools missing from %s:'%args.check_pools_tconf
	for pn, gn in missing:
	    print '  - %s in group %s'%(pn, gn)
    if partially_monitored:
	print 'Unmonitored pools in monitored domains:'
	dns = partially_monitored.keys()
	dns.sort()
	for dn in dns:
	    pns = list(partially_monitored[dn])
	    pns.sort()
	    print '  - In %s: %s'%(dn, ', '.join(pns))
    sys.exit(status_code)
except Exception, xc:
    print 'Exception: %s'%xc
    _0, _1, tb = sys.exc_info()
    for ln in traceback.format_tb(tb):
	print ln,
    sys.exit(3)
